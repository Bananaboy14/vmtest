<!DOCTYPE html>
<html>
<head>
    <title>Desktop Remote</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        .desktop-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .desktop-container canvas {
            background: #000;
            cursor: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .ui-overlay:hover,
        .ui-overlay.show {
            opacity: 1;
        }
        
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9));
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            pointer-events: auto;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            background: #ff4757;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: #2ed573;
            animation: none;
        }
        
        .controls {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }
        
        .control-btn {
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .control-btn.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-color: rgba(255,255,255,0.3);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            font-weight: 300;
            text-align: center;
            z-index: 100;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .mouse-lock-hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2000;
            pointer-events: none;
        }
        
        .mouse-lock-hint.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="desktop-container" id="desktop"></div>
    
    <div class="ui-overlay" id="ui">
        <div class="status-bar">
            <div class="connection-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Connecting...</span>
            </div>
            <div class="controls">
                <button class="control-btn primary" id="connectBtn" onclick="connect()">Connect</button>
                <button class="control-btn" id="lockBtn" onclick="requestPointerLock()">Lock Mouse</button>
                <button class="control-btn" onclick="toggleFullscreen()">Fullscreen</button>
                <button class="control-btn" onclick="disconnect()">Disconnect</button>
            </div>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div>Initializing Desktop Connection</div>
    </div>
    
    <div class="mouse-lock-hint" id="mouseLockHint">
        Click to capture mouse â€¢ Press ESC to release
    </div>

    <script type="module">
        let rfb = null;
        let isConnected = false;
        let isPointerLocked = false;
        let canvas = null;
        let canvasScale = 1;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;
        
        // UI References
        const desktop = document.getElementById('desktop');
        const ui = document.getElementById('ui');
        const loading = document.getElementById('loading');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const connectBtn = document.getElementById('connectBtn');
        const lockBtn = document.getElementById('lockBtn');
        const mouseLockHint = document.getElementById('mouseLockHint');
        
        // Auto-hide UI
        let uiTimeout;
        function showUI() {
            ui.classList.add('show');
            clearTimeout(uiTimeout);
            uiTimeout = setTimeout(() => {
                if (!ui.matches(':hover')) {
                    ui.classList.remove('show');
                }
            }, 3000);
        }
        
        // Mouse movement detection
        document.addEventListener('mousemove', showUI);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isPointerLocked) {
                document.exitPointerLock();
            }
        });
        
        function updateStatus(message, connected = false) {
            statusText.textContent = message;
            if (connected) {
                statusDot.classList.add('connected');
            } else {
                statusDot.classList.remove('connected');
            }
        }
        
        function calculateCanvasTransform() {
            if (!canvas) return;
            
            const container = desktop;
            const containerRect = container.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            canvasScale = Math.min(
                containerRect.width / canvas.width,
                containerRect.height / canvas.height
            );
            
            const scaledWidth = canvas.width * canvasScale;
            const scaledHeight = canvas.height * canvasScale;
            
            canvasOffsetX = (containerRect.width - scaledWidth) / 2;
            canvasOffsetY = (containerRect.height - scaledHeight) / 2;
            
            // Apply perfect scaling
            canvas.style.width = scaledWidth + 'px';
            canvas.style.height = scaledHeight + 'px';
            canvas.style.position = 'absolute';
            canvas.style.left = canvasOffsetX + 'px';
            canvas.style.top = canvasOffsetY + 'px';
            
            console.log(`Canvas: ${canvas.width}x${canvas.height}, Scale: ${canvasScale}, Offset: ${canvasOffsetX},${canvasOffsetY}`);
            // Keep noVNC's internal display scale in sync so client->server
            // coordinate conversion matches the CSS scaling.
            if (typeof rfb !== 'undefined' && rfb && rfb._display) {
                try { rfb._display.scale = canvasScale; } catch (err) { console.warn('Failed to set display scale', err); }
            }
        }
        
        function transformMouseCoordinates(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left) / canvasScale;
            const y = (clientY - rect.top) / canvasScale;
            return { x, y };
        }
        
        // Pointer Lock API
        window.requestPointerLock = function() {
            if (!canvas || !isConnected) return;
            
            canvas.requestPointerLock = canvas.requestPointerLock ||
                                       canvas.mozRequestPointerLock ||
                                       canvas.webkitRequestPointerLock;
            
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
                mouseLockHint.classList.add('show');
                setTimeout(() => {
                    mouseLockHint.classList.remove('show');
                }, 3000);
            }
        };
        
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
            lockBtn.textContent = isPointerLocked ? 'Unlock Mouse' : 'Lock Mouse';
            lockBtn.style.background = isPointerLocked ? 
                'linear-gradient(135deg, #ff6b6b, #ee5a52)' : 
                'rgba(255,255,255,0.1)';
        });
        
        window.connect = async function() {
            if (isConnected) return;
            
            updateStatus('Loading VNC client...');
            connectBtn.disabled = true;
            
            try {
                const { default: RFB } = await import('./core/rfb.js');
                updateStatus('Connecting to desktop...');
                
                desktop.innerHTML = '';
                
                const wsUrl = `ws://${window.location.hostname}:8080/websockify`;
                
                rfb = new RFB(desktop, wsUrl, {
                    credentials: {},
                    focusOnClick: false,
                    clipViewport: false,
                    scaleViewport: false,
                    resizeSession: false,
                    viewOnly: false,
                    showDotCursor: false
                });
                
                rfb.addEventListener('connect', () => {
                    console.log('VNC Connected Successfully');
                    isConnected = true;
                    updateStatus('Desktop Connected', true);
                    loading.style.display = 'none';
                    connectBtn.textContent = 'Connected';
                    connectBtn.disabled = true;
                    
                    canvas = desktop.querySelector('canvas');
                    if (canvas) {
                        canvas.style.cursor = 'none';
                        calculateCanvasTransform();
                        
                        // Enable click-to-lock
                        canvas.addEventListener('click', () => {
                            if (!isPointerLocked) {
                                requestPointerLock();
                            }
                        });
                        
                        // Perfect mouse handling
                        canvas.addEventListener('mousemove', (e) => {
                            if (isPointerLocked) {
                                // Use movement deltas for locked mode
                                rfb.sendPointerEvent(
                                    e.movementX,
                                    e.movementY,
                                    e.buttons,
                                    true
                                );
                            }
                        });
                        
                        canvas.addEventListener('mousedown', (e) => {
                            if (!isPointerLocked) {
                                const coords = transformMouseCoordinates(e.clientX, e.clientY);
                                rfb.sendPointerEvent(coords.x, coords.y, e.buttons);
                            }
                        });
                        
                        canvas.addEventListener('mouseup', (e) => {
                            if (!isPointerLocked) {
                                const coords = transformMouseCoordinates(e.clientX, e.clientY);
                                rfb.sendPointerEvent(coords.x, coords.y, e.buttons);
                            }
                        });
                    }
                });
                
                rfb.addEventListener('disconnect', (e) => {
                    console.log('VNC Disconnected:', e.detail);
                    isConnected = false;
                    isPointerLocked = false;
                    updateStatus('Disconnected');
                    connectBtn.textContent = 'Reconnect';
                    connectBtn.disabled = false;
                    loading.style.display = 'block';
                    loading.querySelector('div:last-child').textContent = 'Connection Lost - Click Reconnect';
                });
                
                rfb.addEventListener('securityfailure', (e) => {
                    console.error('Security failure:', e.detail);
                    updateStatus('Security Error: ' + e.detail.reason);
                });
                
                rfb.addEventListener('desktopsize', () => {
                    console.log('Desktop resized');
                    setTimeout(calculateCanvasTransform, 100);
                });
                
                rfb.addEventListener('clipboard', (e) => {
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(e.detail.text);
                    }
                });
                
            } catch (error) {
                console.error('Connection failed:', error);
                updateStatus('Connection Failed: ' + error.message);
                connectBtn.disabled = false;
                connectBtn.textContent = 'Retry';
            }
        };
        
        window.disconnect = function() {
            if (rfb && isConnected) {
                rfb.disconnect();
            }
        };
        
        window.toggleFullscreen = function() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        };
        
        // Window resize handler
        window.addEventListener('resize', () => {
            if (isConnected && canvas) {
                setTimeout(calculateCanvasTransform, 100);
            }
        });
        
        // Fullscreen change handler
        document.addEventListener('fullscreenchange', () => {
            if (isConnected && canvas) {
                setTimeout(calculateCanvasTransform, 200);
            }
        });
        
        // Initialize
        updateStatus('Ready to Connect');
        
        // Auto-connect immediately
        setTimeout(connect, 500);
        
        // Hide UI initially
        setTimeout(() => {
            ui.classList.remove('show');
        }, 2000);
    </script>
</body>
</html>
