<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ultra-Precise Gaming VNC - Zero Lag Mouse</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: monospace;
            cursor: crosshair;
        }
        
        #viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }
        
        .status {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            z-index: 1000;
            border: 1px solid #0f0;
        }
        
        .mouse-coords {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #ff0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            z-index: 1000;
            border: 1px solid #ff0;
        }
        
        .controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }
        
        .btn {
            background: rgba(0, 50, 100, 0.9);
            color: white;
            border: 1px solid #0af;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-family: monospace;
        }
        
        .btn:hover {
            background: rgba(0, 70, 140, 1);
        }
    </style>
</head>
<body>
    <div id="viewport"></div>
    
    <div class="status" id="status">
        Status: Connecting...<br>
        Mouse: Raw Mode<br>
        Throttling: DISABLED<br>
        Scaling: DISABLED
    </div>
    
    <div class="mouse-coords" id="mouseCoords">
        Mouse: 0, 0<br>
        Last sent: 0, 0<br>
        Moves/sec: 0
    </div>
    
    <div class="controls">
        <button class="btn" onclick="connect()">Connect</button>
        <button class="btn" onclick="toggleLock()">Lock Mouse</button>
        <button class="btn" onclick="resetMouse()">Reset Mouse</button>
    </div>

    <script type="module">
        import { transformMouseCoordinates } from './scripts/mouse_transform.js';
        let socket = null;
        let canvas = null;
        let ctx = null;
        let connected = false;
        let mouseStats = { count: 0, lastTime: Date.now() };
        let lastMousePos = { x: 0, y: 0 };
        
        // Direct WebSocket connection to VNC - bypass noVNC throttling
        function connect() {
            const wsProto = window.location.protocol === "https:" ? "wss" : "ws";
            const wsUrl = `${wsProto}://${window.location.host}/websocket`;
            
            document.getElementById('status').innerHTML = 
                'Status: Connecting...<br>Mouse: Raw Mode<br>Throttling: DISABLED<br>Scaling: DISABLED';
            
            socket = new WebSocket(wsUrl);
            socket.binaryType = 'arraybuffer';
            
            socket.onopen = () => {
                console.log('Direct WebSocket connected');
                document.getElementById('status').innerHTML = 
                    'Status: Connected<br>Mouse: Raw Mode<br>Throttling: DISABLED<br>Scaling: DISABLED';
                connected = true;
                
                // Send RFB handshake
                initRFB();
            };
            
            socket.onmessage = (event) => {
                handleRFBMessage(event.data);
            };
            
            socket.onclose = () => {
                console.log('WebSocket disconnected');
                connected = false;
                document.getElementById('status').innerHTML = 
                    'Status: Disconnected<br>Mouse: --<br>Throttling: --<br>Scaling: --';
            };
            
            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                document.getElementById('status').innerHTML = 
                    'Status: Error<br>Mouse: --<br>Throttling: --<br>Scaling: --';
            };
        }
        
        function initRFB() {
            // Simple RFB initialization - just send version
            const version = "RFB 003.008\n";
            socket.send(new TextEncoder().encode(version));
        }
        
        function handleRFBMessage(data) {
            // For now, just log - we'll implement proper RFB if needed
            console.log('RFB message received:', data.byteLength, 'bytes');
        }
        
        // Ultra-precise mouse handling - no throttling
        function setupMouseHandling() {
            const viewport = document.getElementById('viewport');
            
            // Create a canvas for the desktop
            canvas = document.createElement('canvas');
            canvas.width = 1920;
            canvas.height = 1080;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.objectFit = 'contain';
            viewport.appendChild(canvas);
            
            ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            
            // Raw mouse event handling - no delays or throttling
            canvas.addEventListener('mousemove', (e) => {
                if (!connected) return;

                const coords = transformMouseCoordinates(e.clientX, e.clientY, canvas, viewport);
                if (!coords) return;

                const x = coords.x;
                const y = coords.y;

                // Update display
                document.getElementById('mouseCoords').innerHTML = 
                    `Mouse: ${x}, ${y}<br>Last sent: ${lastMousePos.x}, ${lastMousePos.y}<br>Moves/sec: ${calculateMPS()}`;

                // Send immediately - no throttling
                sendMouseMove(x, y);

                lastMousePos = { x, y };
                mouseStats.count++;
            });
            
            canvas.addEventListener('mousedown', (e) => {
                if (!connected) return;
                const coords = transformMouseCoordinates(e.clientX, e.clientY, canvas, viewport);
                if (!coords) return;
                sendMouseButton(coords.x, coords.y, e.button, true);
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (!connected) return;
                const coords = transformMouseCoordinates(e.clientX, e.clientY, canvas, viewport);
                if (!coords) return;
                sendMouseButton(coords.x, coords.y, e.button, false);
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (!connected) return;

                const coords = transformMouseCoordinates(e.clientX, e.clientY, canvas, viewport);
                if (!coords) return;

                sendMouseWheel(coords.x, coords.y, e.deltaY);
            }, { passive: false });
        }
        
        function calculateMPS() {
            const now = Date.now();
            const elapsed = now - mouseStats.lastTime;
            if (elapsed >= 1000) {
                const mps = Math.round(mouseStats.count * 1000 / elapsed);
                mouseStats.count = 0;
                mouseStats.lastTime = now;
                return mps;
            }
            return 0;
        }
        
        function sendMouseMove(x, y) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            // RFB PointerEvent message format:
            // 1 byte: message type (5 = PointerEvent)
            // 1 byte: button mask
            // 2 bytes: x-position
            // 2 bytes: y-position
            const buffer = new ArrayBuffer(6);
            const view = new DataView(buffer);
            
            view.setUint8(0, 5); // PointerEvent message type
            view.setUint8(1, 0); // No buttons pressed
            view.setUint16(2, x, false); // x position (big-endian)
            view.setUint16(4, y, false); // y position (big-endian)
            
            socket.send(buffer);
        }
        
        function sendMouseButton(x, y, button, pressed) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            let buttonMask = 0;
            if (pressed) {
                switch (button) {
                    case 0: buttonMask = 1; break; // Left
                    case 1: buttonMask = 4; break; // Middle
                    case 2: buttonMask = 2; break; // Right
                }
            }
            
            const buffer = new ArrayBuffer(6);
            const view = new DataView(buffer);
            
            view.setUint8(0, 5); // PointerEvent message type
            view.setUint8(1, buttonMask);
            view.setUint16(2, x, false);
            view.setUint16(4, y, false);
            
            socket.send(buffer);
        }
        
        function sendMouseWheel(x, y, delta) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            // Scroll wheel as button presses
            const buttonMask = delta > 0 ? 8 : 16; // Button 4 (up) or 5 (down)
            
            const buffer = new ArrayBuffer(6);
            const view = new DataView(buffer);
            
            view.setUint8(0, 5);
            view.setUint8(1, buttonMask);
            view.setUint16(2, x, false);
            view.setUint16(4, y, false);
            
            socket.send(buffer);
            
            // Send button release
            setTimeout(() => {
                const buffer2 = new ArrayBuffer(6);
                const view2 = new DataView(buffer2);
                view2.setUint8(0, 5);
                view2.setUint8(1, 0);
                view2.setUint16(2, x, false);
                view2.setUint16(4, y, false);
                socket.send(buffer2);
            }, 1);
        }
        
        // Global functions
        window.connect = connect;
        
        window.toggleLock = function() {
            if (document.pointerLockElement) {
                document.exitPointerLock();
            } else if (canvas) {
                canvas.requestPointerLock();
            }
        };
        
        window.resetMouse = function() {
            fetch('/api/reset-mouse', { method: 'POST' })
                .then(() => console.log('Mouse reset'))
                .catch(() => console.log('Reset failed'));
        };
        
        // Pointer lock handling
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement) {
                console.log('Pointer locked - using raw mouse input');
            } else {
                console.log('Pointer unlocked');
            }
        });
        
        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Initialize
        setupMouseHandling();
        
        // Auto-connect after a short delay
        setTimeout(connect, 1000);
        
        // Test pattern on canvas
        setTimeout(() => {
            if (ctx) {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#0f0';
                ctx.font = '20px monospace';
                ctx.fillText('Ultra-Precise Gaming VNC', 50, 50);
                ctx.fillText('Move mouse to test accuracy', 50, 80);
                ctx.fillText('No throttling, no scaling, raw input', 50, 110);
            }
        }, 2000);

    </script>
</body>
</html>